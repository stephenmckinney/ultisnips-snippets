snippet aft "aft"
after(${1::each}) do
	${2}
end
endsnippet

snippet annot "annot"
any_number_of_times
endsnippet

snippet anr "anr"
and_return(${1:value})
endsnippet

snippet anra "anra"
and_raise(${1:exception})
endsnippet

snippet anrb "anrb"
and_return { ${1} }
endsnippet

snippet ant "ant"
and_throw(${1:sym})
endsnippet

snippet any "any"
and_yield(${1:values})
endsnippet

snippet atl "atl"
at_least(${1:n}).times
endsnippet

snippet atm "atm"
at_most(${1:n}).times
endsnippet

snippet bef "bef"
before(${1::each}) do
	${2}
end
endsnippet

snippet cap "cap"
"([^\"]*)"
endsnippet

snippet conn "conn"
controller_name :${1:controller}
endsnippet

snippet con "con"
context '${1}' do
  ${2}
end
endsnippet

snippet des "des"
describe '${1:subject}' do
	${2}
end
endsnippet

snippet desc "desc"
describe ${1:`!v Snippet_RubyClassNameFromFilename()`} do
	${2}
end
endsnippet

snippet desrc "desrc"
describe ${1:controller}, "${2:GET|POST|PUT|DELETE} ${3:/some/path}${4}" do
	${5}
end
endsnippet

snippet dest "dest"
describe ${1:Type} do
	${2}
end
endsnippet

snippet dests "dests"
describe ${1:Type}, "${2:description}" do
	${3}
end
endsnippet

snippet ex "ex"
exactly(${1:n}).times
endsnippet

snippet Given "Given"
Given /^${1:something} ${2:"([^\"]*)"}$/ do |${3:arg1}|
  ${4:pending}
end
endsnippet

snippet isbl "isbl"
it_should_behave_like '${1:do something}'
endsnippet

snippet it "it"
it '${1:does something}' do
	${2}
end
endsnippet

snippet itb "itb"
it { ${1} }
endsnippet

snippet its "its"
it 'should ${1:do something}' do
	${2}
end
endsnippet

snippet let "let"
let(:${1:subject}) { ${2:value} }
endsnippet

snippet mat "mat"
class ${1:ReverseTo}
	def initialize(${2:param})
		@$2 = $2
	end
	def matches?(actual)
		@actual = actual
		# Satisfy expectation here. Return false or raise an error if it's not met.
		${3:@actual.reverse.should == @$2}
		true
	end
	def failure_message
		"expected #{@actual.inspect} to ${4} #{@$2.inspect}, but it didn't"
	end
	def negative_failure_message
		"expected #{@actual.inspect} not to ${5} #{@$2.inspect}, but it did"
	end
end
def ${6:reverse_to}(${7:expected})
	${8}.new($7)
end
endsnippet

snippet mm "mm"
mock_model(${1:model})${2}
endsnippet

snippet moc "moc"
${1:var} = mock("${2:mock_name}"${3:, :null_object => true})
${4}
endsnippet

snippet mocr "mocr"
${1:var}.should_receive(:${2:a_method}).with(${3:some_params}).and_return(${4:some_object_or_value})
endsnippet

snippet mocw "mocw"
Spec::Runner.configure do |config|
	config.mock_with :${1:mocha|flexmock|rr}
end
endsnippet

snippet on "on"
once
endsnippet

snippet resh "resh"
require File.dirname(__FILE__) + '/../spec_helper'
endsnippet

snippet sef "sef"
shared_examples_for "${1:do something}" do
  ${2}
end
endsnippet

# Shoulds

snippet sh "Should =="
should == ${1:value}
endsnippet

snippet sh "Should be"
should be ${1:comparison} ${2:value}
endsnippet

snippet sh "Should be predicate?"
should be_${1:predicate}
endsnippet

snippet sh "Should be within"
should be_within(${1:delta}).of(${2:value})${3}
endsnippet

snippet sh "Should match"
should match(/${1:regexp}/)${2}
endsnippet

snippet sh "Should include"
should include(${1:value(s)})${2}
endsnippet

snippet sh "Should have n items"
should have(${1:num}).${2:items}
endsnippet

snippet sh "Should have at least n items"
should have_at_least(${1:num}).${2:items}
endsnippet

snippet sh "Should have at most n items"
should have_at_most(${1:num}).${2:items}
endsnippet

snippet sh "Should cover"
should cover(${1:value(s)})${2}
endsnippet

snippet sh "Should be an instance of"
should be_an_instance_of(${1:class}){$2}
endsnippet

snippet sh "Should be a kind of"
should be_a_kind_of(${1:class}){$2}
endsnippet

snippet sh "Should be true"
should be_true${1}
endsnippet

snippet sh "Should be false"
should be_false${1}
endsnippet

snippet sh "Should be nil"
should be_nil${1}
endsnippet

snippet sh "Should eql (object equivalence without type conversions)"
should eql(${1:value})${2}
endsnippet

snippet sh "Should equal (object identity)"
should equal(${1:value})${2}
endsnippet

snippet sh "Should raise error"
expect { ${1:method call} }.to raise_error(${2:Error class}, ${3:message string})${4}
endsnippet

# Should nots

snippet shn "Should not =="
should_not == ${1:value}
endsnippet

snippet shn "Should not be"
should_not be ${1:comparison} ${2:value}
endsnippet

snippet shn "Should not be predicate?"
should_not be_${1:predicate}
endsnippet

snippet shn "Should not be within"
should_not be_within(${1:delta}).of(${2:value})${3}
endsnippet

snippet shn "Should not match"
should_not match(/${1:regexp}/)${2}
endsnippet

snippet shn "Should not include"
should_not include(${1:value(s)})${2}
endsnippet

snippet shn "Should not have n items"
should_not have(${1:num}).${2:items}
endsnippet

snippet shn "Should not cover"
should_not cover(${1:value(s)})${2}
endsnippet

snippet shn "Should not be an instance of"
should_not be_an_instance_of(${1:class}){$2}
endsnippet

snippet shn "Should not be a kind of"
should_not be_a_kind_of(${1:class}){$2}
endsnippet

snippet shn "Should not be true"
should_not be_true${1}
endsnippet

snippet shn "Should not be false"
should_not be_false${1}
endsnippet

snippet shn "Should not be nil"
should_not be_nil${1}
endsnippet

snippet shn "Should not eql (object equivalence without type conversions)"
should_not eql(${1:value})${2}
endsnippet

snippet shn "Should not equal (object identity)"
should_not equal(${1:value})${2}
endsnippet

snippet shn "Should not raise error"
expect { ${1:method call} }.to_not raise_error(${2:Error class}, ${3:message string})${4}
endsnippet

snippet stu "stu"
${1:var}.stub!(:${2:a_method}).and_return(${3:some_object_or_value})
endsnippet

snippet sub "sub"
subject { ${1:value} }${2}
endsnippet

snippet Then "Then"
Then /^${1:something} ${2:"([^\"]*)"}$/ do |${3:arg1}|
  ${4:pending}
end
endsnippet

snippet tw "tw"
twice
endsnippet

snippet When "When"
When /^${1:something} ${2:"([^\"]*)"}$/ do |${3:arg1}|
  ${4:pending}
end
endsnippet

snippet wia "wia"
with(${1:args})
${2}
endsnippet

# vim:ft=snippets:
